export const ROADMAP_CHECKER_SNIPPET = [
  "#!/usr/bin/env node",
  "// Minimal roadmap checker for the dashboard.",
  "// Reads docs/roadmap.yml and writes docs/roadmap-status.json",
  "",
  "import fs from \"node:fs\";",
  "import path from \"node:path\";",
  "import yaml from \"js-yaml\";",
  "",
  "const ROOT = process.cwd();",
  "const ROADMAP_YML = path.join(ROOT, \"docs\", \"roadmap.yml\");",
  "const STATUS_JSON = path.join(ROOT, \"docs\", \"roadmap-status.json\");",
  "",
  "function readYaml(p) {",
  "  if (!fs.existsSync(p)) throw new Error(`Missing ${p}`);",
  "  return yaml.load(fs.readFileSync(p, \"utf8\"));",
  "}",
  "",
  "async function http_ok({ url, must_match = [] }) {",
  "  const r = await fetch(url, { cache: \"no-store\" });",
  "  if (!r.ok) return { ok: false, code: r.status };",
  "  const text = await r.text();",
  "  const matched = must_match.every((m) => text.includes(m));",
  "  return { ok: matched, code: r.status };",
  "}",
  "",
  "async function files_exist({ globs }) {",
  "  // minimal: treat globs as literal paths",
  "  const ok = globs.every((g) => fs.existsSync(path.join(ROOT, g)));",
  "  return { ok };",
  "}",
  "",
  "async function sql_exists({ query }) {",
  "  const url = process.env.READ_ONLY_CHECKS_URL;",
  "  if (!url) return { ok: false, error: \"READ_ONLY_CHECKS_URL not set\" };",
  "  const attempts = [",
  "    JSON.stringify({ queries: [query] }),",
  "    JSON.stringify({ query }),",
  "    JSON.stringify({ symbol: query }),",
  "    JSON.stringify(query)",
  "  ];",
  "  for (const body of attempts) {",
  "    const r = await fetch(url, {",
  "      method: \"POST\",",
  "      headers: { \"content-type\": \"application/json\" },",
  "      body",
  "    });",
  "    const text = await r.text();",
  "    let json = null;",
  "    try { json = text ? JSON.parse(text) : null; } catch {}",
  "    if (typeof json?.ok === \"boolean\") return { ok: json.ok };",
  "    const arr = Array.isArray(json?.results) ? json.results : Array.isArray(json) ? json : [];",
  "    const match = arr.find((entry) => entry && [entry.q, entry.query, entry.symbol].includes(query));",
  "    if (match && typeof match.ok === \"boolean\") return { ok: match.ok };",
  "    if (!r.ok) return { ok: false, code: r.status, error: text.slice(0, 200) };",
  "  }",
  "  return { ok: false, error: \"Unexpected response from read_only_checks\" };",
  "}",
  "",
  "async function runCheck(chk) {",
  "  if (chk.type === \"files_exist\") return files_exist(chk);",
  "  if (chk.type === \"http_ok\")",
  "    return http_ok(chk);",
  "  if (chk.type === \"sql_exists\")",
  "    return sql_exists(chk);",
  "  return { ok: false, error: `unknown check type: ${chk.type}` };",
  "}",
  "",
  "async function main() {",
  "  const rm = readYaml(ROADMAP_YML);",
  "  const out = { generated_at: new Date().toISOString(), weeks: [] };",
  "",
  "  for (const w of rm.weeks ?? []) {",
  "    const wOut = { id: w.id, title: w.title, items: [] };",
  "    for (const it of w.items ?? []) {",
  "      let passed = true;",
  "      const results = [];",
  "      for (const chk of it.checks ?? []) {",
  "        const res = await runCheck(chk);",
  "        results.push({ ...chk, ...res });",
  "        if (!res.ok) passed = false;",
  "      }",
  "      wOut.items.push({ id: it.id, name: it.name, done: passed, results });",
  "    }",
  "    out.weeks.push(wOut);",
  "  }",
  "",
  "  fs.mkdirSync(path.dirname(STATUS_JSON), { recursive: true });",
  "  fs.writeFileSync(STATUS_JSON, JSON.stringify(out, null, 2));",
  "  console.log(`Wrote ${STATUS_JSON}`);",
  "}",
  "",
  "main().catch((e) => {",
  "  console.error(e);",
  "  process.exit(1);",
  "});",
].join("\n");
