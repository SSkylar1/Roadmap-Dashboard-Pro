export const ROADMAP_CHECKER_SNIPPET = [
  "#!/usr/bin/env node",
  "// Minimal roadmap checker for the dashboard.",
  "// Reads docs/roadmap.yml and writes docs/roadmap-status.json",
  "",
  "import fs from \"node:fs\";",
  "import path from \"node:path\";",
  "import yaml from \"js-yaml\";",
  "",
  "const ROOT = process.cwd();",
  "const ROADMAP_YML = path.join(ROOT, \"docs\", \"roadmap.yml\");",
  "const STATUS_JSON = path.join(ROOT, \"docs\", \"roadmap-status.json\");",
  "",
  "function parse_probe_headers(raw) {",
  "  if (!raw) return {};",
  "  if (typeof raw === \"string\") {",
  "    const trimmed = raw.trim();",
  "    if (!trimmed) return {};",
  "    try { return parse_probe_headers(JSON.parse(trimmed)); } catch {}",
  "    const headers = {};",
  "    for (const part of trimmed.split(/[\\n;,]+/)) {",
  "      const piece = part.trim();",
  "      if (!piece) continue;",
  "      const idx = piece.indexOf(\":\");",
  "      if (idx === -1) continue;",
  "      const key = piece.slice(0, idx).trim();",
  "      const value = piece.slice(idx + 1).trim();",
  "      if (key && value) headers[key] = value;",
  "    }",
  "    return headers;",
  "  }",
  "  if (typeof raw === \"object\") {",
  "    const headers = {};",
  "    for (const [key, value] of Object.entries(raw)) {",
  "      if (typeof value === \"string\" && value.trim()) headers[key.trim()] = value.trim();",
  "    }",
  "    return headers;",
  "  }",
  "  return {};",
  "}",
  "",
  "function search_container(query, container) {",
  "  if (!container) return undefined;",
  "  if (typeof container === \"boolean\") return container;",
  "  if (Array.isArray(container)) {",
  "    for (const entry of container) {",
  "      if (!entry || typeof entry !== \"object\") continue;",
  "      const candidates = [entry.q, entry.query, entry.symbol, entry.id, entry.identifier, entry.name];",
  "      if (candidates.includes(query) && typeof entry.ok === \"boolean\") return entry.ok;",
  "      const nested = search_container(query, entry);",
  "      if (typeof nested === \"boolean\") return nested;",
  "    }",
  "    return undefined;",
  "  }",
  "  if (typeof container === \"object\") {",
  "    if (typeof container.ok === \"boolean\") return container.ok;",
  "    if (query in container) {",
  "      const direct = container[query];",
  "      if (typeof direct === \"boolean\") return direct;",
  "      if (direct && typeof direct === \"object\" && typeof direct.ok === \"boolean\") return direct.ok;",
  "    }",
  "    for (const value of Object.values(container)) {",
  "      const nested = search_container(query, value);",
  "      if (typeof nested === \"boolean\") return nested;",
  "    }",
  "  }",
  "  return undefined;",
  "}",
  "",
  "function extract_ok(query, payload) {",
  "  if (typeof payload === \"boolean\") return payload;",
  "  if (!payload) return undefined;",
  "  if (typeof payload === \"object\") {",
  "    if (typeof payload.ok === \"boolean\") return payload.ok;",
  "    const containers = [];",
  "    if (Array.isArray(payload)) containers.push(payload);",
  "    if (payload.checks) containers.push(payload.checks);",
  "    if (payload.results) containers.push(payload.results);",
  "    if (payload.result) containers.push(payload.result);",
  "    if (payload.data) containers.push(payload.data);",
  "    if (payload.data && payload.data.results) containers.push(payload.data.results);",
  "    if (payload.payload) containers.push(payload.payload);",
  "    for (const container of containers) {",
  "      const matched = search_container(query, container);",
  "      if (typeof matched === \"boolean\") return matched;",
  "    }",
  "  }",
  "  return undefined;",
  "}",
  "",
  "const EXTRA_HEADERS = parse_probe_headers(process.env.READ_ONLY_CHECKS_HEADERS);",
  "",
  "function readYaml(p) {",
  "  if (!fs.existsSync(p)) throw new Error(`Missing ${p}`);",
  "  return yaml.load(fs.readFileSync(p, \"utf8\"));",
  "}",
  "",
  "async function http_ok({ url, must_match = [] }) {",
  "  const r = await fetch(url, { cache: \"no-store\" });",
  "  if (!r.ok) return { ok: false, code: r.status };",
  "  const text = await r.text();",
  "  const matched = must_match.every((m) => text.includes(m));",
  "  return { ok: matched, code: r.status };",
  "}",
  "",
  "async function files_exist({ globs }) {",
  "  // minimal: treat globs as literal paths",
  "  const ok = globs.every((g) => fs.existsSync(path.join(ROOT, g)));",
  "  return { ok };",
  "}",
  "",
  "async function sql_exists({ query }) {",
  "  const url = process.env.READ_ONLY_CHECKS_URL;",
  "  if (!url) return { ok: false, error: \"READ_ONLY_CHECKS_URL not set\" };",
  "  const headers = { \"content-type\": \"application/json\", ...EXTRA_HEADERS };",
  "  const attempts = [",
  "    { label: \"queries\", body: JSON.stringify({ queries: [query] }) },",
  "    { label: \"query\", body: JSON.stringify({ query }) },",
  "    { label: \"symbols\", body: JSON.stringify({ symbols: [query] }) },",
  "    { label: \"symbol\", body: JSON.stringify({ symbol: query }) },",
  "    { label: \"symbols_single\", body: JSON.stringify({ symbols: query }) },",
  "    { label: \"raw\", body: JSON.stringify(query) }",
  "  ];",
  "  let lastError = \"\";",
  "  let lastCode;",
  "  for (const attempt of attempts) {",
  "    try {",
  "      const r = await fetch(url, {",
  "        method: \"POST\",",
  "        headers,",
  "        body: attempt.body",
  "      });",
  "      const text = await r.text();",
  "      let json = null;",
  "      if (text) {",
  "        try { json = JSON.parse(text); } catch {",
  "          const normalized = text.trim().toLowerCase();",
  "          if ([\"ok\", \"true\", \"ok:true\"].includes(normalized)) return { ok: true };",
  "        }",
  "      }",
  "      const ok = extract_ok(query, json);",
  "      if (typeof ok === \"boolean\") return { ok };",
  "      const detail =",
  "        (json && (json.error || json.message)) ||",
  "        (typeof text === \"string\" ? text.trim() : \"\") ||",
  "        `Unexpected response via ${attempt.label}`;",
  "      if (!r.ok) {",
  "        lastCode = r.status;",
  "        lastError = `${r.status} ${detail}`.trim();",
  "      } else {",
  "        lastError = detail;",
  "      }",
  "    } catch (error) {",
  "      lastError = error?.message || String(error);",
  "    }",
  "  }",
  "  return { ok: false, ...(typeof lastCode === \"number\" ? { code: lastCode } : {}), error: lastError || \"Unexpected response from read_only_checks\" };",
  "}",
  "",
  "async function runCheck(chk) {",
  "  if (chk.type === \"files_exist\") return files_exist(chk);",
  "  if (chk.type === \"http_ok\")",
  "    return http_ok(chk);",
  "  if (chk.type === \"sql_exists\")",
  "    return sql_exists(chk);",
  "  return { ok: false, error: `unknown check type: ${chk.type}` };",
  "}",
  "",
  "async function main() {",
  "  const rm = readYaml(ROADMAP_YML);",
  "  const out = { generated_at: new Date().toISOString(), weeks: [] };",
  "",
  "  for (const w of rm.weeks ?? []) {",
  "    const wOut = { id: w.id, title: w.title, items: [] };",
  "    for (const it of w.items ?? []) {",
  "      let passed = true;",
  "      const checks = [];",
  "      for (const chk of it.checks ?? []) {",
  "        const res = await runCheck(chk);",
  "        const ok = typeof res.ok === \"boolean\" ? res.ok : undefined;",
  "        const status = ok === undefined ? \"unknown\" : ok ? \"pass\" : \"fail\";",
  "        checks.push({ ...chk, ...res, ...(ok !== undefined ? { ok } : {}), status, result: status });",
  "        if (ok !== true) passed = false;",
  "      }",
  "      wOut.items.push({ id: it.id, name: it.name, done: passed, checks, results: checks });",
  "    }",
  "    out.weeks.push(wOut);",
  "  }",
  "",
  "  fs.mkdirSync(path.dirname(STATUS_JSON), { recursive: true });",
  "  fs.writeFileSync(STATUS_JSON, JSON.stringify(out, null, 2));",
  "  console.log(`Wrote ${STATUS_JSON}`);",
  "}",
  "",
  "main().catch((e) => {",
  "  console.error(e);",
  "  process.exit(1);",
  "});",
].join("\n");
